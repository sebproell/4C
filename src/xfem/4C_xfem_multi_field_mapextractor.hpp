// This file is part of 4C multiphysics licensed under the
// GNU Lesser General Public License v3.0 or later.
//
// See the LICENSE.md file in the top-level for license information.
//
// SPDX-License-Identifier: LGPL-3.0-or-later

#ifndef FOUR_C_XFEM_MULTI_FIELD_MAPEXTRACTOR_HPP
#define FOUR_C_XFEM_MULTI_FIELD_MAPEXTRACTOR_HPP

#include "4C_config.hpp"

#include "4C_coupling_adapter_converter.hpp"
#include "4C_linalg_vector.hpp"
#include "4C_utils_exceptions.hpp"
#include "4C_xfem_enum_lists.hpp"

#include <memory>
#include <set>

// forward declarations
class Epetra_Map;

FOUR_C_NAMESPACE_OPEN

namespace Core::FE
{
  class Discretization;
}  // namespace Core::FE

namespace Core::Nodes
{
  class Node;
}

namespace Core::Elements
{
  class Element;
}

namespace Core::LinAlg
{
  class SparseOperator;
  class SparseMatrix;
  class BlockSparseMatrixBase;
  class MultiMapExtractor;
}  // namespace Core::LinAlg

namespace XFEM
{
  namespace XFieldField
  {
    class CouplingDofSet;
    class Coupling;
  }  // namespace XFieldField

  /** \class MultiFieldMapExtractor
   *  \brief MultiFieldMapExtractor class to handle different discretizations
   *  with joint interfaces
   *
   *  This class is supposed to be used for problems including one or more
   *  standard field discretizations and one or more xFEM field
   *  discretizations. These discretizations should be generated by splitting
   *  one large discretization, such that the joint interfaces of two (or more)
   *  discretizations are node-matching. The XFEM discretizations are allowed
   *  to be enriched at a number of interface nodes. This is considered during
   *  the creation process of the common unique DoF row map. Furthermore, the
   *  discretizations are allowed to be distributed differently over the
   *  processors (also at the joint interfaces).
   *
   *  The objective of this class is, to create a full map which can be used to
   *  create the necessary state vectors and system matrices and to simplify
   *  the communication between the different discretizations by providing
   *  appropriate extract and insert methods.
   *
   *  Simple 2-dimensional example:
   *
   *  We start with the following discretization. (+) nodes indicate standard
   *  nodes, (o) indicate enriched (or possible enriched) nodes.
   *
   *      +---+---+    nodal GID's from left to right:  0  1  2
   *      |   |   |
   *      o---+---+                                     3  4  5
   *      |   |   |
   *      o---+---+                                     6  7  8
   *      |   |   |
   *      o---+---+                                     9 10 11
   *      |   |   |
   *      o---+---+                                    12 13 14
   *      |   |   |
   *      +---+---+                                    15 16 17
   *
   *  Before you can call this class, you have to split the discretization into
   *  a standard and a xFEM discretization. This can be achieved in different
   *  ways. One possibility is to use the XFEM::Utils::XFEMDiscretizationBuilder.
   *  Both discretizations are supposed to share still the same nodal global
   *  ID's at their joint interfaces.
   *
   *      +---+---+   0  1  2
   *      |   |   |
   *      +---+---+   3  4  5                   o---+   3  4
   *          |   |                             |   |
   *          +---+      7  8                   o---+   6  7
   *          |   |                 AND         |   |
   *          +---+     10 11                   o---+   9 10
   *          |   |                             |   |
   *      +---+---+  12 13 14                   o---+  12 13
   *      |   |   |
   *      +---+---+  15 16 17
   *
   *      STANDARD                              XFEM
   *
   *  Now this class starts to find all interface nodes between the different
   *  discretizations and creates an auxiliary interface discretization
   *  containing only these shared nodes.
   *
   *               o   +   3  4
   *
   *                   +      7
   *
   *                   +     10
   *
   *               o   +  12 13
   *
   *  The helping discretization is allowed to be distributed differently,
   *  although it is not recommended because of the resulting communication
   *  overhead.
   *
   */
  class MultiFieldMapExtractor
  {
    typedef std::vector<std::shared_ptr<const Core::FE::Discretization>> XDisVec;

    // number of map extractor types
    static constexpr unsigned NUM_MAP_TYPES = 2;

   public:
    /// constructor
    MultiFieldMapExtractor();

    /// destructor
    virtual ~MultiFieldMapExtractor() = default;

    /** \brief Initialize the MultiMapExtractor using a set of filled discretizations
     *
     *  Everything is initialized what is independent of any possible up-coming
     *  redistribution.
     *
     *  \param dis_vec (in): Vector containing different in some way connected
     *                       standard and/or xFEM discretizations.
     *  \param max_num_reserved_dofs_per_node (in): This is the maximal possible number
     *                       of DoF's per enriched node (necessary for the fixed size
     *                       dofset).
     *
     */
    void init(const std::vector<std::shared_ptr<const Core::FE::Discretization>>& dis_vec,
        int max_num_reserved_dofs_per_node);

    /** \brief Setup member variables
     *
     *  Everything is initialized what will change if one of the
     *  discretizations in the discretization vector (see init()) is
     *  redistributed.
     *
     */
    virtual void setup();

    /// @name Accessors to the auxiliary interface discretization
    /// @{

    /** \brief access the interface node with given global id
     *
     *  \param gid (in): global id of the interface node
     *
     */
    Core::Nodes::Node* g_i_node(const int& gid) const;

    /// access the interface node row map
    const Epetra_Map* i_node_row_map() const;

    /** \brief get the number of DoF's of the given interface node
     *
     *  Returns the maximum number of DoF's of the jointing discretizations
     *  at the interface node
     *
     *  \param inode (in): pointer to the interface node
     *
     */
    int i_num_dof(const Core::Nodes::Node* inode) const;

    /// get the number of standard DoF's of the discretization
    int i_num_standard_dof() const;


    int i_dof(const Core::Nodes::Node* inode, int dof) const;

    void i_dof(const Core::Nodes::Node* inode, std::vector<int>& dofs) const;

    void i_dof(std::vector<int>& dof, Core::Nodes::Node* inode, unsigned nodaldofset_id,
        const Core::Elements::Element* element) const;

    /// @}

    const Core::LinAlg::MultiMapExtractor& sl_dof_map_extractor(enum FieldName field) const
    {
      return sl_map_extractor(slave_id(field), map_dofs);
    }

    std::shared_ptr<const Epetra_Map> node_row_map(
        enum FieldName field, enum MultiField::BlockType block) const;

    /** \brief return TRUE if the given global node id corresponds to an
     *  interface node
     *
     */
    bool is_interface_node(const int& ngid) const;

    /// Access the full maps
    const std::shared_ptr<const Epetra_Map>& full_map(enum MapType map_type = map_dofs) const;

    /// @name Extract vector routines
    /// @{
    std::shared_ptr<Core::LinAlg::Vector<double>> extract_vector(
        const Core::LinAlg::Vector<double>& full, enum FieldName field,
        enum MapType map_type = map_dofs) const;

    std::shared_ptr<Core::LinAlg::MultiVector<double>> extract_vector(
        const Core::LinAlg::MultiVector<double>& full, enum FieldName field,
        enum MapType map_type = map_dofs) const;

    inline void extract_vector(const Core::LinAlg::MultiVector<double>& full, enum FieldName field,
        Core::LinAlg::MultiVector<double>& partial, enum MapType map_type = map_dofs) const
    {
      extract_vector(full, slave_id(field), partial, map_type);
    }

    void extract_vector(const Core::LinAlg::MultiVector<double>& full, int block,
        Core::LinAlg::MultiVector<double>& partial, enum MapType map_type = map_dofs) const;

    inline void extract_element_vector(const Core::LinAlg::MultiVector<double>& full,
        enum FieldName field, Core::LinAlg::MultiVector<double>& partial) const
    {
      extract_element_vector(full, slave_id(field), partial);
    }

    void extract_element_vector(const Core::LinAlg::MultiVector<double>& full, int block,
        Core::LinAlg::MultiVector<double>& partial) const;
    /// @}

    /// @name Routines to insert a partial vector into a full vector
    /// @{

    /** \brief Put a partial vector into a full Core::LinAlg::Vector<double>
     *
     *  \param partial (in): vector to copy into full vector (Core::LinAlg::Vector<double>)
     *  \param field   (in): field name enumerator of the partial vector
     *
     *  */
    std::shared_ptr<Core::LinAlg::Vector<double>> insert_vector(
        const Core::LinAlg::Vector<double>& partial, enum FieldName field,
        enum MapType map_type = map_dofs) const;

    /** \brief Put a partial vector into a full vector (Core::LinAlg::MultiVector<double>)
     *
     *  \param partial (in): vector to copy into full vector
     *  \param field   (in): field name enumerator of the partial vector
     *
     *  */
    std::shared_ptr<Core::LinAlg::MultiVector<double>> insert_vector(
        const Core::LinAlg::MultiVector<double>& partial, enum FieldName field,
        enum MapType map_type = map_dofs) const;

    /** \brief Put a partial vector into a full vector (Core::LinAlg::MultiVector<double>)
     *
     *  \param partial (in): vector to copy into full vector
     *  \param field   (in): field name enumerator of the partial vector
     *  \param full   (out): vector to copy into
     *
     *  */
    void insert_vector(const Core::LinAlg::MultiVector<double>& partial, enum FieldName field,
        Core::LinAlg::MultiVector<double>& full, enum MapType map_type = map_dofs) const
    {
      return insert_vector(partial, slave_id(field), full, map_type);
    }

    /** \brief Put a partial vector into a full vector (Core::LinAlg::MultiVector<double>) [derived]
     *
     *  */
    void insert_vector(const Core::LinAlg::MultiVector<double>& partial, int block,
        Core::LinAlg::MultiVector<double>& full, enum MapType map_type = map_dofs) const;

    inline void insert_element_vector(const Core::LinAlg::MultiVector<double>& partial,
        enum FieldName field, Core::LinAlg::MultiVector<double>& full) const
    {
      insert_element_vector(partial, slave_id(field), full);
    }

    void insert_element_vector(const Core::LinAlg::MultiVector<double>& partial, int block,
        Core::LinAlg::MultiVector<double>& full) const;
    /// @}

    /// @name Routines to add a partial vector to the full vector
    /// @{
    /** \brief Add a partial vector to a full vector (Core::LinAlg::Vector<double>)
     *
     *  \param partial (in): vector which is added to full vector
     *  \param field   (in): field name enumerator of the partial vector
     *  \param full   (out): sum into this full vector
     *  \param scale   (in): scaling factor for partial vector
     *
     *  */
    inline void add_vector(const Core::LinAlg::Vector<double>& partial, enum FieldName field,
        Core::LinAlg::Vector<double>& full, double scale, enum MapType map_type = map_dofs) const
    {
      add_vector(partial, slave_id(field), full, scale, map_type);
    }

    /** \brief Add a partial vector to a full vector (Core::LinAlg::MultiVector<double>)
     *
     *  \param partial (in): vector which is added to the full vector
     *  \param field   (in): field name enumerator of the partial vector
     *  \param full   (out): sum into this full vector
     *  \param scale   (in): scaling factor for partial vector
     *
     *  */
    inline void add_vector(const Core::LinAlg::MultiVector<double>& partial, enum FieldName field,
        Core::LinAlg::MultiVector<double>& full, double scale,
        enum MapType map_type = map_dofs) const
    {
      return add_vector(partial, slave_id(field), full, scale, map_type);
    }

    /** \brief Add a partial vector to a full vector (Core::LinAlg::MultiVector<double>) [derived]
     *
     *  */
    void add_vector(const Core::LinAlg::MultiVector<double>& partial, int block,
        Core::LinAlg::MultiVector<double>& full, double scale,
        enum MapType map_type = map_dofs) const;

    inline void add_element_vector(const Core::LinAlg::MultiVector<double>& partial,
        enum FieldName field, Core::LinAlg::MultiVector<double>& full, double scale) const
    {
      add_element_vector(partial, slave_id(field), full, scale);
    }

    void add_element_vector(const Core::LinAlg::MultiVector<double>& partial, int block,
        Core::LinAlg::MultiVector<double>& full, double scale) const;
    /// @}

    /// @name Add a partial system-matrix to the full matrix
    /// @{
    inline void add_matrix(const Core::LinAlg::SparseOperator& partial_mat, enum FieldName field,
        Core::LinAlg::SparseOperator& full_mat, double scale)
    {
      add_matrix(partial_mat, slave_id(field), full_mat, scale);
    }

    void add_matrix(const Core::LinAlg::SparseOperator& partial_mat, int block,
        Core::LinAlg::SparseOperator& full_mat, double scale);

    void add_matrix(const Core::LinAlg::BlockSparseMatrixBase& partial_mat, int block,
        Core::LinAlg::SparseMatrix& full_mat, double scale);

    /// @}

    /** \brief return TRUE if the discretization dis_id is a XFEM discretization
     *
     *  \param dis_id (in): entry of the slave discretization vector
     *
     */
    bool is_x_fem_dis(enum FieldName field) const { return is_x_fem_dis(slave_id(field)); }

   protected:
    /// check if init() has been called yet
    inline void check_init() const
    {
      if (not isinit_) FOUR_C_THROW("Call init() first!");
    }

    /// check if init() and setup() have been called yet
    inline void check_init_setup() const
    {
      if ((not isinit_) or (not issetup_)) FOUR_C_THROW("Call init() and/or setup() first!");
    }

   private:
    /** \brief return TRUE if the discretization dis_id is a XFEM discretization
     *
     *  \param dis_id (in): entry of the slave discretization vector
     *
     */
    bool is_x_fem_dis(int dis_id) const;

    /** \brief  Access the master interface node row map of the interface
     *  between the master interface discretization and the slave discretization
     *  with the ID dis_id
     *
     *  \param dis_id (in): entry of the slave discretization vector
     *
     */
    inline const Epetra_Map& master_interface_node_row_map(enum FieldName field) const
    {
      return master_interface_node_row_map(slave_id(field));
    }
    const Epetra_Map& master_interface_node_row_map(unsigned dis_id) const
    {
      check_init();

      if (dis_id >= master_interface_node_maps_.size())
        FOUR_C_THROW(
            "The index {} exceeds the master interface node row map size! "
            "(size = {})",
            dis_id, master_interface_node_maps_.size());

      if (master_interface_node_maps_[dis_id] == nullptr)
        FOUR_C_THROW(
            "The master interface node row map {} was not initialized "
            "correctly.",
            dis_id);

      return *(master_interface_node_maps_[dis_id]);
    }

    /** \brief Access the master map extractor
     *
     */
    const Core::LinAlg::MultiMapExtractor& ma_map_extractor(enum MapType map_type) const
    {
      if (master_map_extractor_.at(map_type) == nullptr)
        FOUR_C_THROW("The master dof/node map extractor was not initialized!");

      return *(master_map_extractor_[map_type]);
    }

    /** \brief Access the slave sided node row maps
     *
     *  \param dis_id (in): block id of the desired discretization
     *  \param btype  (in): choose between interface and non-interface nodes
     *
     */
    inline const Epetra_Map& slave_node_row_map(
        enum XFEM::FieldName field, enum MultiField::BlockType btype) const
    {
      return slave_node_row_map(slave_id(field), btype);
    }
    const Epetra_Map& slave_node_row_map(unsigned dis_id, enum MultiField::BlockType btype) const;

    const Core::LinAlg::MultiMapExtractor& sl_map_extractor(
        unsigned dis_id, enum MapType map_type) const
    {
      check_init();

      if (dis_id >= slave_map_extractors_.size())
        FOUR_C_THROW(
            "The index {} exceeds the slave map extractor size! "
            "(size = {})",
            dis_id, slave_map_extractors_.size());

      if (slave_map_extractors_[dis_id].at(map_type) == nullptr)
        FOUR_C_THROW(
            "The slave dof/node map extractor {} was not initialized "
            "correctly.",
            dis_id);

      return *(slave_map_extractors_[dis_id][map_type]);
    }

    /** \brief Access the interface matrix row transformer for the given field
     *
     *  */
    Coupling::Adapter::MatrixRowTransform& i_mat_row_transform(enum FieldName field)
    {
      return i_mat_row_transform(slave_id(field));
    }
    Coupling::Adapter::MatrixRowTransform& i_mat_row_transform(unsigned dis_id)
    {
      check_init();

      if (dis_id >= interface_matrix_row_transformers_.size())
        FOUR_C_THROW(
            "The index {} exceeds the matrix row transformer size! "
            "(size = {})",
            dis_id, interface_matrix_row_transformers_.size());

      if (interface_matrix_row_transformers_[dis_id] == nullptr)
        FOUR_C_THROW(
            "The interface matrix row transformer {} was not initialized "
            "correctly.",
            dis_id);

      return *(interface_matrix_row_transformers_[dis_id]);
    }

    /** \brief Access the interface matrix column transformer for the given field
     *
     *  */
    Coupling::Adapter::MatrixColTransform& i_mat_col_transform(enum FieldName field)
    {
      return i_mat_col_transform(slave_id(field));
    }
    Coupling::Adapter::MatrixColTransform& i_mat_col_transform(unsigned dis_id)
    {
      check_init();

      if (dis_id >= interface_matrix_col_transformers_.size())
        FOUR_C_THROW(
            "The index {} exceeds the matrix column transformer size! "
            "(size = {})",
            dis_id, interface_matrix_col_transformers_.size());

      if (interface_matrix_col_transformers_[dis_id] == nullptr)
        FOUR_C_THROW(
            "The interface matrix column transformer {} was not initialized "
            "correctly.",
            dis_id);

      return *(interface_matrix_col_transformers_[dis_id]);
    }

    /** \brief Access the interface matrix row and column transformer for the given field
     *
     *  */
    Coupling::Adapter::MatrixRowColTransform& i_mat_row_col_transform(enum FieldName field)
    {
      return i_mat_row_col_transform(slave_id(field));
    }
    Coupling::Adapter::MatrixRowColTransform& i_mat_row_col_transform(unsigned dis_id)
    {
      check_init();

      if (dis_id >= interface_matrix_row_col_transformers_.size())
        FOUR_C_THROW(
            "The index {} exceeds the matrix row col transformer size! "
            "(size = {})",
            dis_id, interface_matrix_row_col_transformers_.size());

      if (interface_matrix_row_col_transformers_[dis_id] == nullptr)
        FOUR_C_THROW(
            "The interface matrix row col transformer {} was not initialized "
            "correctly.",
            dis_id);

      return *(interface_matrix_row_col_transformers_[dis_id]);
    }

    /** \brief Access the interface discretization
     *
     *  */
    inline const Core::FE::Discretization& i_discret() const
    {
      check_init();
      return *idiscret_;
    }

    inline const Core::FE::Discretization& sl_discret(enum FieldName field) const
    {
      return sl_discret(slave_id(field));
    }
    const Core::FE::Discretization& sl_discret(unsigned dis_id) const
    {
      check_init();

      if (dis_id >= num_sl_dis())
        FOUR_C_THROW(
            "The index {} exceeds the slave discretization vector size! "
            "(size = {})",
            dis_id, sl_dis_vec().size());

      if (sl_dis_vec()[dis_id] == nullptr)
        FOUR_C_THROW(
            "The slave discretization {} was not initialized "
            "correctly.",
            dis_id);

      return *(sl_dis_vec()[dis_id]);
    }

    const XFEM::XFieldField::Coupling& i_coupling(unsigned dis_id) const
    {
      check_init();
      if (dis_id >= interface_couplings_.size())
        FOUR_C_THROW(
            "The index {} exceeds the interface coupling size! "
            "(size = {})",
            dis_id, interface_couplings_.size());
      if (interface_couplings_[dis_id] == nullptr)
        FOUR_C_THROW(
            "The interface coupling {} was not initialized "
            "correctly.",
            dis_id);

      return *(interface_couplings_[dis_id]);
    }

    inline MPI_Comm get_comm() const
    {
      if (!comm_) FOUR_C_THROW("The MPI_Comm object has not been initialized!");

      return comm_;
    }

    inline unsigned num_sl_dis() const { return sl_dis_vec().size(); }

    const std::set<int>& g_interface_node_gid_set() const { return g_interface_node_gid_set_; }

    /** \brief reset class variables at the beginning of each init() and setup() call
     *
     *  \param num_dis_vec (in): number of wrapped discretizations
     *  \param full        (in): TRUE initiates a reset of all class variables */
    void reset(unsigned num_dis_vec) { reset(num_dis_vec, true); }
    void reset(unsigned num_dis_vec, bool full);

    /// get the row node/DoF maps of the wrapped discretizations
    void get_dof_and_node_maps();

    void build_global_interface_node_gid_set();

    void build_master_interface_node_maps(
        const std::vector<std::vector<int>>& my_master_interface_node_gids);

    void build_slave_discret_id_map();

    int slave_id(enum FieldName field) const;

    const std::vector<std::shared_ptr<const Core::FE::Discretization>>& sl_dis_vec() const
    {
      return slave_discret_vec_;
    }

    void build_slave_dof_map_extractors();

    void build_slave_node_map_extractors();

    void build_master_node_map_extractor();

    void build_master_dof_map_extractor();

    void build_element_map_extractor();

    /** \brief Build the interface coupling DoF set and complete the interface
     *  discretization
     *
     */
    void build_interface_coupling_dof_set();

    void build_interface_coupling_adapters();

    void build_interface_matrix_transformers();

   private:
    /// boolean which indicates, that the init() routine has been called
    bool isinit_;

    /// boolean which indicates, that the setup() routine has been called
    bool issetup_;

    int max_num_reserved_dofs_per_node_;

    /// Epetra communicator
    MPI_Comm comm_;

    /// vector containing pointers to all the input discretizations
    std::vector<std::shared_ptr<const Core::FE::Discretization>> slave_discret_vec_;

    /// mapping between the FieldName enumerator and the slave vector entry number
    std::map<enum FieldName, int> slave_discret_id_map_;

    /** \brief global interface node GID set
     *
     * (containing the same information on all proc's) */
    std::set<int> g_interface_node_gid_set_;

    std::vector<std::shared_ptr<const Epetra_Map>> master_interface_node_maps_;

    std::vector<std::vector<std::shared_ptr<Core::LinAlg::MultiMapExtractor>>>
        slave_map_extractors_;
    std::vector<std::shared_ptr<Core::LinAlg::MultiMapExtractor>> master_map_extractor_;

    std::shared_ptr<Core::LinAlg::MultiMapExtractor> element_map_extractor_;

    std::vector<std::shared_ptr<XFEM::XFieldField::Coupling>> interface_couplings_;

    std::vector<std::shared_ptr<Coupling::Adapter::MatrixRowTransform>>
        interface_matrix_row_transformers_;
    std::vector<std::shared_ptr<Coupling::Adapter::MatrixColTransform>>
        interface_matrix_col_transformers_;
    std::vector<std::shared_ptr<Coupling::Adapter::MatrixRowColTransform>>
        interface_matrix_row_col_transformers_;

    std::set<int> xfem_dis_ids_;

    /// interface discretization
    std::shared_ptr<Core::FE::Discretization> idiscret_;

    /// interface coupling DoF-set
    std::shared_ptr<XFEM::XFieldField::CouplingDofSet> icoupl_dofset_;

  };  // class MapExtractor
}  // namespace XFEM


FOUR_C_NAMESPACE_CLOSE

#endif
